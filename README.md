Python
Python Thread Study
1.  Python Thread 基础
        在sleep千分之一秒后可以发现，多线程的随机运行
        线程的创建：
            继承threading.Thread类，覆写run方法
                run方法是设定线程的工作，比如输出，操作字符串，文件，列表等
        线程的运行：
            创建“继承threading.Thread类”，调用对象的start()方法，线程运行
            每个对象的start方法只能调用一次
        需要注意的是：
            每个线程一定会有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。
            当线程的run()方法结束时该线程完成。
            无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。
            基本的运行里没有共享数据，没有锁的实现
2.  Python 中的互斥锁或同步锁
        lock=threading.Lock()生成一个锁对象
        lock.acquire([time])对资源加锁，在同一时刻只有一个线程会得到锁，time是个可选的时间值，如果在time时间内没有得到锁\
            会返回false以进行其它后继的处理
        lock.release()方法释放锁后，其它的线程才会再次进行抢锁操作
3.  Python中的死锁以及可重入锁 
        死锁的原因是锁A会依赖B锁的释放而释放，B锁会依赖A锁的释放而释放，如果都正常释放不会有问题，如果哪一方没即时放锁，则一定会死锁
        但这程情况并不固定，会根据程序的队列调度不同而结果不同，有时不死锁，有时死锁
        另一程情况是一个线程“迭代”请求一个资源，则直接死锁
        避免这个的方法是使用python提供的一种可重入锁，RLock(),这种锁自带计数器，只有都释放了锁，其它的线程才会获得锁